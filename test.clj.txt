(ns pdf.test
  (:use 
    pdf.core
    hard.core))
   

(comment 
(CLEAN)

;;;;;;;;;;;;;;;;;
(macroexpand '(rule joe [a] :d))
(rule divide [] :default)
(rule divide [a b] :default)
(rule divide [^number? a ^number? b] (/ a b))
(rule divide [^vector3? a ^number? b] (V÷ a b))
(rule divide [a b] {b {1 true 1.0 true}} [:identity a])
(rule divide [a b] {b (every-pred number? zero?)} :error-divide-by-zero)
(rule divide [a ^vector3? b] :error-divide-by-vector)

;compiled
(fn 
  ([a] 
    ((fn [a] :default) a))
  ([a b] 
    (if (vector3? b) 
      (fn [a b] :error-divide-by-vector)
      (if ((every-pred number? zero?) b) 
        (fn [a b] :error-divide-by-zero) 
        (if ({1 true, 1.0 true} b) 
          (fn [a b] [:identity a]) 
          (if (number? b) 
            (if (vector3? a) 
              (fn [a b] (V÷ a b)) 
              (if (number? a) 
                (fn [a b] (/ a b)) 
                (fn [a b] :default))) 
            (fn [a b] :default)))))))

(divide (->v3 1 2 3) 3.0)
;#unity/Vector3 [0.3333333 0.6666667 1.0]
(divide 8 0)
;:error-divide-by-zero

; perf
(def test-data
  (vec (take 10000
    (partition 2 (repeatedly #(rand-nth [nil (->v3 (rand-vec 100 100 10)) (rand) (rand-int 10)]))))))

(time (do 
  (mapv (fn [[a b]] (divide a b)) test-data)
      true))
;52-60 ms



neg?

;;;;;;;;;;;;;;;;;;
(CLEAN)
(def non-number? (non number?))

(rule maxim [a b] (max a b))
(rule maxim [^neg? a ^pos? b] b)
(rule maxim [^pos? a ^neg? b] a)
(rule maxim [^non-number? a b] b)
(rule maxim [a ^non-number? b] a)
(rule maxim [^non-number? a ^non-number? b] :numeric-err)


(if (non-number? z) 
  (if (non-number? y) 
    (do :numeric-err) 
    (do b)) 
  (if (non-number? y) 
    (do a) 
    (if (and (neg? y) (pos? z)) 
      (do a) 
      (if (and (pos? y) (neg? z)) 
        (do b) 
        (do (max a b))))))









(rule testo [a b] :default)
(rule testo [^sequential? a ^sequential? b] [:s :s])
(rule testo [^number? a ^vector? b] [:n :v])
(rule testo [^sequential? a ^vector? b] [:s :v])
(rule testo [^number? a ^sequential? b] [:n :s])

;; output
(fn
  ([a b] 
    (if (number? a) 
      (if (sequential? b) 
        (fn [a b] [:n :s]) 
        (if (vector? b) 
          (if (sequential? a) 
            (fn [a b] [:s :v]) 
            (fn [a b] [:n :v])) 
          (fn [a b] :default))) 
      (if (sequential? a) 
        (if (vector? b) 
          (fn [a b] [:s :v]) 
          (if (sequential? b) 
            (fn [a b] [:s :s]) 
            (fn [a b] :default))) 
        (fn [a b] :default)))))


















(CLEAN)

(def fizz? #(= 0 (mod % 3)))
(def buzz? #(= 0 (mod % 5)))
(def wozz? #(= 0 (mod % 7)))

(rule fizz [a b c d e] 
  :default)
(rule fizz [^fizz? a ^number? b c ^:dog d ^sequential? e] 
  :fizzy-dogs)
(rule fizz [^sequential?  a ^fizz? b ^even? c ^string? d e] 
  [:fizzy d])
(rule fizz [a ^wozz? b ^fizz? c d e] 
  [a :woz :fizz])
(rule fizz [^buzz? a  ^number? b ^fizz? c ^number? d ^sequential? e] 
  [a b :fizz])

(fn
  ([a b c d e] 
    (if (number? b) 
      (if (fizz? c) 
        (if (sequential? e) 
          (if (and (buzz? a) (number? d)) 
          (fn [a b c d e] [a b :fizz]) 
          (if (wozz? b) 
            (fn [a b c d e] [a :woz :fizz]) 
            (if (and (sequential? a) (even? c) (fizz? b) (string? d)) 
              (fn [a b c d e] [:fizzy d]) 
              (if (fizz? a) (fn [a b c d e] :fizzy-dogs) 
                (fn [a b c d e] :default))))) (if (wozz? b) 
          (fn [a b c d e] [a :woz :fizz]) 
          (if (and (fizz? b) (even? c) (sequential? a) (string? d)) 
            (fn [a b c d e] [:fizzy d]) 
            (fn [a b c d e] :default)))) 
        (if (and (sequential? a) (even? c) (fizz? b) (string? d)) 
          (fn [a b c d e] [:fizzy d]) (if (and (fizz? a) (sequential? e)) 
            (fn [a b c d e] :fizzy-dogs) 
            (fn [a b c d e] :default)))) 
      (if (and (fizz? c) (wozz? b)) 
        (fn [a b c d e] [a :woz :fizz]) 
        (if (and (even? c) (fizz? b) (sequential? a) (string? d)) 
          (fn [a b c d e] [:fizzy d]) 
          (fn [a b c d e] :default))))))


(get-in @DISPATCHMAP [#'pdf.test/fizz 5 :compiled])
(fizz 10 2 6 4 [5])

;output
(if (number? y) 
  (if (fizz? x) 
    (if (sequential? v) 
      (if (and (buzz? z) (number? w)) 
        (do [a b :fizz]) 
        (if (wozz? y) 
          (do [a :woz :fizz]) 
          (if (and (sequential? z) (even? x) (fizz? y) (string? w)) 
            (do [:fizzy d]) 
            (if (fizz? z) 
              (do :fizzy-dogs) 
              (do :default))))) 
      (if (wozz? y) 
        (do [a :woz :fizz]) 
        (if (and (fizz? y) (even? x) (sequential? z) (string? w)) 
          (do [:fizzy d]) 
          (do :default)))) 
    (if (and (sequential? z) (even? x) (fizz? y) (string? w)) 
      (do [:fizzy d]) 
      (if (and (fizz? z) (sequential? v)) 
        (do :fizzy-dogs) 
        (do :default)))) 
  (if (and (fizz? x) (wozz? y)) 
    (do [a :woz :fizz]) 
    (if (and (even? x) (fizz? y) (sequential? z) (string? w)) 
      (do [:fizzy d]) 
      (do :default))))







(declare look unseq)
(def unseq flatten)
(def test-item
  {:noun "chest" :material "wooden" 
   :closed false 
   :container 
   [{:noun "spoon" :material "tin"}
    {:noun "bag" :material "leather"
     :closed true
     :container 
     [{:noun "coin" :material "copper"}
      {:noun "coin" :material "gold"}]}]})
  
(rule describe [^:vector3? o] {}
    (unseq "it contains" (map write-name o))) 

(rule describe [^empty? o] {} "it's empty") 


(rule describe [o] 
  {o (a (non :closed) :container)}
  "inside " (describe (:container o)))

(rule describe [o] 
  {o (a :closed :container)} 
  "it is closed")

(rule item-state [o] 
  {o :contents}
  (if (:closed o) "closed" "open"))

(rule write-article [o] {} "the")

(rule write-adjectives [o] {}
  (interpose "," 
    (unseq 
      (item-state o) 
      (:material o))))

(rule write-name [o] {} "thing")

(rule write-name [^:noun o] {} (:noun o))

(rule look [o] {} 
  "You don't see anything.")

(rule look [^map? o] {} 
  (unseq 
    "You look at"
    (write-article o)
    (write-adjectives o)
    (write-name o) "."
    (describe o)))

(def t (make-pred-matrix (identity (get-in @DISPATCHMAP [#'pdf.core/describe 1  :rule]))))
(walk-table t)

(do (unseq "it contains" (map write-name o)) 
  (if ((a :closed :container) z) 
    (do "it is closed") 
    (if ((a (non :closed) :container) z) 
      (do "inside " (describe (:container o))) 
      (if (empty? z) 
        (do "it's empty")))))

(look 7)
(look test-item)
(look (first (:container test-item)))

)